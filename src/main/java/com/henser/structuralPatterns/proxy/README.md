
## 工程说明

* 代理模式（proxy pattern）

## 模式说明

* 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

## 模式的结构

* 所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

## 这个模式的角色

* 抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
* 目标对象角色：定义了代理对象所代表的目标对象。
* 代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。

## 静态代理

* 静态代理，为我们带来了一定的灵活性，是我们在不改变原来的被代理类的方法的情况下，通过在调用处替换被代理类的实例化语句为代理类的实例化语句的方式，实现了改动少量的代码（只改动了调用处的一行代码），就获得额外动作的功能。
* 由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。

## JDK 动态代理

* 观察代码可以发现每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理，而且，所有的代理操作除了调用的方法不一样之外，其他的操作都一样，则此时肯定是重复代码。解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。 
* 再来看一下动态代理： 
  JDK动态代理中包含一个类和一个接口： 
  InvocationHandler接口： 
  public interface InvocationHandler { 
  public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; 
  } 
  参数说明： 
  Object proxy：指被代理的对象。 
  Method method：要调用的方法 
  Object[] args：方法调用时所需要的参数 
  
  可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。
  
* Proxy类： 
  Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法： 
  public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, 
  InvocationHandler h) 
                                 throws IllegalArgumentException 
  参数说明： 
  ClassLoader loader：类加载器 
  Class<?>[] interfaces：得到全部的接口 
  InvocationHandler h：得到InvocationHandler接口的子类实例 
  
  Ps:类加载器 
  在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有一下三种类加载器; 
  Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的； 
  Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类; 
  AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。
   
* 与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。
* JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。

## CGLib 动态代理

* cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。

## 模式优点
* 我们通过在原有的调用逻辑过程中，再抽一个代理类的方式，使调用逻辑的变化尽可能的封装再代理类的内部中，达到不去改动原有被代理类的方法的情况下，增加新的动作的效果。
* 这就使得即便在未来的使用场景中有更多的拓展，改变也依然很难波及被代理类，我们也就可以放心的对被代理类的特定方法进行复用了

## 模式缺点
* 静态代理和JDK动态代理都需要被代理类的接口信息以确定特定的方法进行拦截和包装。
* CGLib动态代理虽然不需要接口信息，但是它拦截并包装被代理类的所有方法。


